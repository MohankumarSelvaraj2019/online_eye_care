/*!
 * jQuery UI Touch Punch 0.2.3
 *
 * Copyright 2011ï¿½2014, Dave Furfero
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Depends:
 *  jquery.ui.widget.js
 *  jquery.ui.mouse.js
 */
! function(a) {
    function f(a, b) {
        if (!(a.originalEvent.touches.length > 1)) {
            a.preventDefault();
            var c = a.originalEvent.changedTouches[0],
                d = document.createEvent("MouseEvents");
            d.initMouseEvent(b, !0, !0, window, 1, c.screenX, c.screenY, c.clientX, c.clientY, !1, !1, !1, !1, 0, null), a.target.dispatchEvent(d)
        }
    }
    if (a.support.touch = "ontouchend" in document, a.support.touch) {
        var e, b = a.ui.mouse.prototype,
            c = b._mouseInit,
            d = b._mouseDestroy;
        b._touchStart = function(a) {
            var b = this;
            !e && b._mouseCapture(a.originalEvent.changedTouches[0]) && (e = !0, b._touchMoved = !1, f(a, "mouseover"), f(a, "mousemove"), f(a, "mousedown"))
        }, b._touchMove = function(a) {
            e && (this._touchMoved = !0, f(a, "mousemove"))
        }, b._touchEnd = function(a) {
            e && (f(a, "mouseup"), f(a, "mouseout"), this._touchMoved || f(a, "click"), e = !1)
        }, b._mouseInit = function() {
            var b = this;
            b.element.bind({
                touchstart: a.proxy(b, "_touchStart"),
                touchmove: a.proxy(b, "_touchMove"),
                touchend: a.proxy(b, "_touchEnd")
            }), c.call(b)
        }, b._mouseDestroy = function() {
            var b = this;
            b.element.unbind({
                touchstart: a.proxy(b, "_touchStart"),
                touchmove: a.proxy(b, "_touchMove"),
                touchend: a.proxy(b, "_touchEnd")
            }), d.call(b)
        }
    }
}(jQuery);;
/*!
 * @fileOverview TouchSwipe - jQuery Plugin
 * @version 1.6.18
 *
 * @author Matt Bryson http://www.github.com/mattbryson
 * @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
 * @see http://labs.rampinteractive.co.uk/touchSwipe/
 * @see http://plugins.jquery.com/project/touchSwipe
 * @license
 * Copyright (c) 2010-2015 Matt Bryson
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 */
! function(factory) {
    "function" == typeof define && define.amd && define.amd.jQuery ? define(["jquery"], factory) : factory("undefined" != typeof module && module.exports ? require("jquery") : jQuery)
}(function($) {
    "use strict";

    function init(options) {
        return !options || void 0 !== options.allowPageScroll || void 0 === options.swipe && void 0 === options.swipeStatus || (options.allowPageScroll = NONE), void 0 !== options.click && void 0 === options.tap && (options.tap = options.click), options || (options = {}), options = $.extend({}, $.fn.swipe.defaults, options), this.each(function() {
            var $this = $(this),
                plugin = $this.data(PLUGIN_NS);
            plugin || (plugin = new TouchSwipe(this, options), $this.data(PLUGIN_NS, plugin))
        })
    }

    function TouchSwipe(element, options) {
        function touchStart(jqEvent) {
            if (!(getTouchInProgress() || $(jqEvent.target).closest(options.excludedElements, $element).length > 0)) {
                var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
                if (!event.pointerType || "mouse" != event.pointerType || 0 != options.fallbackToMouseEvents) {
                    var ret, touches = event.touches,
                        evt = touches ? touches[0] : event;
                    return phase = PHASE_START, touches ? fingerCount = touches.length : options.preventDefaultEvents !== !1 && jqEvent.preventDefault(), distance = 0, direction = null, currentDirection = null, pinchDirection = null, duration = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, pinchDistance = 0, maximumsMap = createMaximumsData(), cancelMultiFingerRelease(), createFingerData(0, evt), !touches || fingerCount === options.fingers || options.fingers === ALL_FINGERS || hasPinches() ? (startTime = getTimeStamp(), 2 == fingerCount && (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)), (options.swipeStatus || options.pinchStatus) && (ret = triggerHandler(event, phase))) : ret = !1, ret === !1 ? (phase = PHASE_CANCEL, triggerHandler(event, phase), ret) : (options.hold && (holdTimeout = setTimeout($.proxy(function() {
                        $element.trigger("hold", [event.target]), options.hold && (ret = options.hold.call($element, event, event.target))
                    }, this), options.longTapThreshold)), setTouchInProgress(!0), null)
                }
            }
        }

        function touchMove(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            if (phase !== PHASE_END && phase !== PHASE_CANCEL && !inMultiFingerRelease()) {
                var ret, touches = event.touches,
                    evt = touches ? touches[0] : event,
                    currentFinger = updateFingerData(evt);
                if (endTime = getTimeStamp(), touches && (fingerCount = touches.length), options.hold && clearTimeout(holdTimeout), phase = PHASE_MOVE, 2 == fingerCount && (0 == startTouchesDistance ? (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)) : (updateFingerData(touches[1]), endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end), pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end)), pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance), pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance)), fingerCount === options.fingers || options.fingers === ALL_FINGERS || !touches || hasPinches()) {
                    if (direction = calculateDirection(currentFinger.start, currentFinger.end), currentDirection = calculateDirection(currentFinger.last, currentFinger.end), validateDefaultEvent(jqEvent, currentDirection), distance = calculateDistance(currentFinger.start, currentFinger.end), duration = calculateDuration(), setMaxDistance(direction, distance), ret = triggerHandler(event, phase), !options.triggerOnTouchEnd || options.triggerOnTouchLeave) {
                        var inBounds = !0;
                        if (options.triggerOnTouchLeave) {
                            var bounds = getbounds(this);
                            inBounds = isInBounds(currentFinger.end, bounds)
                        }!options.triggerOnTouchEnd && inBounds ? phase = getNextPhase(PHASE_MOVE) : options.triggerOnTouchLeave && !inBounds && (phase = getNextPhase(PHASE_END)), phase != PHASE_CANCEL && phase != PHASE_END || triggerHandler(event, phase)
                    }
                } else phase = PHASE_CANCEL, triggerHandler(event, phase);
                ret === !1 && (phase = PHASE_CANCEL, triggerHandler(event, phase))
            }
        }

        function touchEnd(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent,
                touches = event.touches;
            if (touches) {
                if (touches.length && !inMultiFingerRelease()) return startMultiFingerRelease(event), !0;
                if (touches.length && inMultiFingerRelease()) return !0
            }
            return inMultiFingerRelease() && (fingerCount = fingerCountAtRelease), endTime = getTimeStamp(), duration = calculateDuration(), didSwipeBackToCancel() || !validateSwipeDistance() ? (phase = PHASE_CANCEL, triggerHandler(event, phase)) : options.triggerOnTouchEnd || options.triggerOnTouchEnd === !1 && phase === PHASE_MOVE ? (options.preventDefaultEvents !== !1 && jqEvent.preventDefault(), phase = PHASE_END, triggerHandler(event, phase)) : !options.triggerOnTouchEnd && hasTap() ? (phase = PHASE_END, triggerHandlerForGesture(event, phase, TAP)) : phase === PHASE_MOVE && (phase = PHASE_CANCEL, triggerHandler(event, phase)), setTouchInProgress(!1), null
        }

        function touchCancel() {
            fingerCount = 0, endTime = 0, startTime = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, cancelMultiFingerRelease(), setTouchInProgress(!1)
        }

        function touchLeave(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            options.triggerOnTouchLeave && (phase = getNextPhase(PHASE_END), triggerHandler(event, phase))
        }

        function removeListeners() {
            $element.unbind(START_EV, touchStart), $element.unbind(CANCEL_EV, touchCancel), $element.unbind(MOVE_EV, touchMove), $element.unbind(END_EV, touchEnd), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave), setTouchInProgress(!1)
        }

        function getNextPhase(currentPhase) {
            var nextPhase = currentPhase,
                validTime = validateSwipeTime(),
                validDistance = validateSwipeDistance(),
                didCancel = didSwipeBackToCancel();
            return !validTime || didCancel ? nextPhase = PHASE_CANCEL : !validDistance || currentPhase != PHASE_MOVE || options.triggerOnTouchEnd && !options.triggerOnTouchLeave ? !validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave && (nextPhase = PHASE_CANCEL) : nextPhase = PHASE_END, nextPhase
        }

        function triggerHandler(event, phase) {
            var ret, touches = event.touches;
            return (didSwipe() || hasSwipes()) && (ret = triggerHandlerForGesture(event, phase, SWIPE)), (didPinch() || hasPinches()) && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, PINCH)), didDoubleTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP) : didLongTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, LONG_TAP) : didTap() && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, TAP)), phase === PHASE_CANCEL && touchCancel(event), phase === PHASE_END && (touches ? touches.length || touchCancel(event) : touchCancel(event)), ret
        }

        function triggerHandlerForGesture(event, phase, gesture) {
            var ret;
            if (gesture == SWIPE) {
                if ($element.trigger("swipeStatus", [phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection]), options.swipeStatus && (ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection), ret === !1)) return !1;
                if (phase == PHASE_END && validateSwipe()) {
                    if (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), $element.trigger("swipe", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipe && (ret = options.swipe.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection), ret === !1)) return !1;
                    switch (direction) {
                        case LEFT:
                            $element.trigger("swipeLeft", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeLeft && (ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                            break;
                        case RIGHT:
                            $element.trigger("swipeRight", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeRight && (ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                            break;
                        case UP:
                            $element.trigger("swipeUp", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeUp && (ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                            break;
                        case DOWN:
                            $element.trigger("swipeDown", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeDown && (ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection))
                    }
                }
            }
            if (gesture == PINCH) {
                if ($element.trigger("pinchStatus", [phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchStatus && (ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData), ret === !1)) return !1;
                if (phase == PHASE_END && validatePinch()) switch (pinchDirection) {
                    case IN:
                        $element.trigger("pinchIn", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchIn && (ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData));
                        break;
                    case OUT:
                        $element.trigger("pinchOut", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchOut && (ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData))
                }
            }
            return gesture == TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), hasDoubleTap() && !inDoubleTap() ? (doubleTapStartTime = getTimeStamp(), singleTapTimeout = setTimeout($.proxy(function() {
                doubleTapStartTime = null, $element.trigger("tap", [event.target]), options.tap && (ret = options.tap.call($element, event, event.target))
            }, this), options.doubleTapThreshold)) : (doubleTapStartTime = null, $element.trigger("tap", [event.target]), options.tap && (ret = options.tap.call($element, event, event.target)))) : gesture == DOUBLE_TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), doubleTapStartTime = null, $element.trigger("doubletap", [event.target]), options.doubleTap && (ret = options.doubleTap.call($element, event, event.target))) : gesture == LONG_TAP && (phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), doubleTapStartTime = null, $element.trigger("longtap", [event.target]), options.longTap && (ret = options.longTap.call($element, event, event.target)))), ret
        }

        function validateSwipeDistance() {
            var valid = !0;
            return null !== options.threshold && (valid = distance >= options.threshold), valid
        }

        function didSwipeBackToCancel() {
            var cancelled = !1;
            return null !== options.cancelThreshold && null !== direction && (cancelled = getMaxDistance(direction) - distance >= options.cancelThreshold), cancelled
        }

        function validatePinchDistance() {
            return null !== options.pinchThreshold ? pinchDistance >= options.pinchThreshold : !0
        }

        function validateSwipeTime() {
            var result;
            return result = options.maxTimeThreshold ? !(duration >= options.maxTimeThreshold) : !0
        }

        function validateDefaultEvent(jqEvent, direction) {
            if (options.preventDefaultEvents !== !1)
                if (options.allowPageScroll === NONE) jqEvent.preventDefault();
                else {
                    var auto = options.allowPageScroll === AUTO;
                    switch (direction) {
                        case LEFT:
                            (options.swipeLeft && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
                            break;
                        case RIGHT:
                            (options.swipeRight && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
                            break;
                        case UP:
                            (options.swipeUp && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
                            break;
                        case DOWN:
                            (options.swipeDown && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
                            break;
                        case NONE:
                    }
                }
        }

        function validatePinch() {
            var hasCorrectFingerCount = validateFingers(),
                hasEndPoint = validateEndPoint(),
                hasCorrectDistance = validatePinchDistance();
            return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance
        }

        function hasPinches() {
            return !!(options.pinchStatus || options.pinchIn || options.pinchOut)
        }

        function didPinch() {
            return !(!validatePinch() || !hasPinches())
        }

        function validateSwipe() {
            var hasValidTime = validateSwipeTime(),
                hasValidDistance = validateSwipeDistance(),
                hasCorrectFingerCount = validateFingers(),
                hasEndPoint = validateEndPoint(),
                didCancel = didSwipeBackToCancel(),
                valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
            return valid
        }

        function hasSwipes() {
            return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown)
        }

        function didSwipe() {
            return !(!validateSwipe() || !hasSwipes())
        }

        function validateFingers() {
            return fingerCount === options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH
        }

        function validateEndPoint() {
            return 0 !== fingerData[0].end.x
        }

        function hasTap() {
            return !!options.tap
        }

        function hasDoubleTap() {
            return !!options.doubleTap
        }

        function hasLongTap() {
            return !!options.longTap
        }

        function validateDoubleTap() {
            if (null == doubleTapStartTime) return !1;
            var now = getTimeStamp();
            return hasDoubleTap() && now - doubleTapStartTime <= options.doubleTapThreshold
        }

        function inDoubleTap() {
            return validateDoubleTap()
        }

        function validateTap() {
            return (1 === fingerCount || !SUPPORTS_TOUCH) && (isNaN(distance) || distance < options.threshold)
        }

        function validateLongTap() {
            return duration > options.longTapThreshold && DOUBLE_TAP_THRESHOLD > distance
        }

        function didTap() {
            return !(!validateTap() || !hasTap())
        }

        function didDoubleTap() {
            return !(!validateDoubleTap() || !hasDoubleTap())
        }

        function didLongTap() {
            return !(!validateLongTap() || !hasLongTap())
        }

        function startMultiFingerRelease(event) {
            previousTouchEndTime = getTimeStamp(), fingerCountAtRelease = event.touches.length + 1
        }

        function cancelMultiFingerRelease() {
            previousTouchEndTime = 0, fingerCountAtRelease = 0
        }

        function inMultiFingerRelease() {
            var withinThreshold = !1;
            if (previousTouchEndTime) {
                var diff = getTimeStamp() - previousTouchEndTime;
                diff <= options.fingerReleaseThreshold && (withinThreshold = !0)
            }
            return withinThreshold
        }

        function getTouchInProgress() {
            return !($element.data(PLUGIN_NS + "_intouch") !== !0)
        }

        function setTouchInProgress(val) {
            $element && (val === !0 ? ($element.bind(MOVE_EV, touchMove), $element.bind(END_EV, touchEnd), LEAVE_EV && $element.bind(LEAVE_EV, touchLeave)) : ($element.unbind(MOVE_EV, touchMove, !1), $element.unbind(END_EV, touchEnd, !1), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave, !1)), $element.data(PLUGIN_NS + "_intouch", val === !0))
        }

        function createFingerData(id, evt) {
            var f = {
                start: {
                    x: 0,
                    y: 0
                },
                last: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: 0
                }
            };
            return f.start.x = f.last.x = f.end.x = evt.pageX || evt.clientX, f.start.y = f.last.y = f.end.y = evt.pageY || evt.clientY, fingerData[id] = f, f
        }

        function updateFingerData(evt) {
            var id = void 0 !== evt.identifier ? evt.identifier : 0,
                f = getFingerData(id);
            return null === f && (f = createFingerData(id, evt)), f.last.x = f.end.x, f.last.y = f.end.y, f.end.x = evt.pageX || evt.clientX, f.end.y = evt.pageY || evt.clientY, f
        }

        function getFingerData(id) {
            return fingerData[id] || null
        }

        function setMaxDistance(direction, distance) {
            direction != NONE && (distance = Math.max(distance, getMaxDistance(direction)), maximumsMap[direction].distance = distance)
        }

        function getMaxDistance(direction) {
            return maximumsMap[direction] ? maximumsMap[direction].distance : void 0
        }

        function createMaximumsData() {
            var maxData = {};
            return maxData[LEFT] = createMaximumVO(LEFT), maxData[RIGHT] = createMaximumVO(RIGHT), maxData[UP] = createMaximumVO(UP), maxData[DOWN] = createMaximumVO(DOWN), maxData
        }

        function createMaximumVO(dir) {
            return {
                direction: dir,
                distance: 0
            }
        }

        function calculateDuration() {
            return endTime - startTime
        }

        function calculateTouchesDistance(startPoint, endPoint) {
            var diffX = Math.abs(startPoint.x - endPoint.x),
                diffY = Math.abs(startPoint.y - endPoint.y);
            return Math.round(Math.sqrt(diffX * diffX + diffY * diffY))
        }

        function calculatePinchZoom(startDistance, endDistance) {
            var percent = endDistance / startDistance * 1;
            return percent.toFixed(2)
        }

        function calculatePinchDirection() {
            return 1 > pinchZoom ? OUT : IN
        }

        function calculateDistance(startPoint, endPoint) {
            return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)))
        }

        function calculateAngle(startPoint, endPoint) {
            var x = startPoint.x - endPoint.x,
                y = endPoint.y - startPoint.y,
                r = Math.atan2(y, x),
                angle = Math.round(180 * r / Math.PI);
            return 0 > angle && (angle = 360 - Math.abs(angle)), angle
        }

        function calculateDirection(startPoint, endPoint) {
            if (comparePoints(startPoint, endPoint)) return NONE;
            var angle = calculateAngle(startPoint, endPoint);
            return 45 >= angle && angle >= 0 ? LEFT : 360 >= angle && angle >= 315 ? LEFT : angle >= 135 && 225 >= angle ? RIGHT : angle > 45 && 135 > angle ? DOWN : UP
        }

        function getTimeStamp() {
            var now = new Date;
            return now.getTime()
        }

        function getbounds(el) {
            el = $(el);
            var offset = el.offset(),
                bounds = {
                    left: offset.left,
                    right: offset.left + el.outerWidth(),
                    top: offset.top,
                    bottom: offset.top + el.outerHeight()
                };
            return bounds
        }

        function isInBounds(point, bounds) {
            return point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom
        }

        function comparePoints(pointA, pointB) {
            return pointA.x == pointB.x && pointA.y == pointB.y
        }
        var options = $.extend({}, options),
            useTouchEvents = SUPPORTS_TOUCH || SUPPORTS_POINTER || !options.fallbackToMouseEvents,
            START_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerDown" : "pointerdown" : "touchstart" : "mousedown",
            MOVE_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerMove" : "pointermove" : "touchmove" : "mousemove",
            END_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerUp" : "pointerup" : "touchend" : "mouseup",
            LEAVE_EV = useTouchEvents ? SUPPORTS_POINTER ? "mouseleave" : null : "mouseleave",
            CANCEL_EV = SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerCancel" : "pointercancel" : "touchcancel",
            distance = 0,
            direction = null,
            currentDirection = null,
            duration = 0,
            startTouchesDistance = 0,
            endTouchesDistance = 0,
            pinchZoom = 1,
            pinchDistance = 0,
            pinchDirection = 0,
            maximumsMap = null,
            $element = $(element),
            phase = "start",
            fingerCount = 0,
            fingerData = {},
            startTime = 0,
            endTime = 0,
            previousTouchEndTime = 0,
            fingerCountAtRelease = 0,
            doubleTapStartTime = 0,
            singleTapTimeout = null,
            holdTimeout = null;
        try {
            $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel)
        } catch (e) {
            $.error("events not supported " + START_EV + "," + CANCEL_EV + " on jQuery.swipe")
        }
        this.enable = function() {
            return this.disable(), $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel), $element
        }, this.disable = function() {
            return removeListeners(), $element
        }, this.destroy = function() {
            removeListeners(), $element.data(PLUGIN_NS, null), $element = null
        }, this.option = function(property, value) {
            if ("object" == typeof property) options = $.extend(options, property);
            else if (void 0 !== options[property]) {
                if (void 0 === value) return options[property];
                options[property] = value
            } else {
                if (!property) return options;
                $.error("Option " + property + " does not exist on jQuery.swipe.options")
            }
            return null
        }
    }
    var VERSION = "1.6.18",
        LEFT = "left",
        RIGHT = "right",
        UP = "up",
        DOWN = "down",
        IN = "in",
        OUT = "out",
        NONE = "none",
        AUTO = "auto",
        SWIPE = "swipe",
        PINCH = "pinch",
        TAP = "tap",
        DOUBLE_TAP = "doubletap",
        LONG_TAP = "longtap",
        HORIZONTAL = "horizontal",
        VERTICAL = "vertical",
        ALL_FINGERS = "all",
        DOUBLE_TAP_THRESHOLD = 10,
        PHASE_START = "start",
        PHASE_MOVE = "move",
        PHASE_END = "end",
        PHASE_CANCEL = "cancel",
        SUPPORTS_TOUCH = "ontouchstart" in window,
        SUPPORTS_POINTER_IE10 = window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !SUPPORTS_TOUCH,
        SUPPORTS_POINTER = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !SUPPORTS_TOUCH,
        PLUGIN_NS = "TouchSwipe",
        defaults = {
            fingers: 1,
            threshold: 75,
            cancelThreshold: null,
            pinchThreshold: 20,
            maxTimeThreshold: null,
            fingerReleaseThreshold: 250,
            longTapThreshold: 500,
            doubleTapThreshold: 200,
            swipe: null,
            swipeLeft: null,
            swipeRight: null,
            swipeUp: null,
            swipeDown: null,
            swipeStatus: null,
            pinchIn: null,
            pinchOut: null,
            pinchStatus: null,
            click: null,
            tap: null,
            doubleTap: null,
            longTap: null,
            hold: null,
            triggerOnTouchEnd: !0,
            triggerOnTouchLeave: !1,
            allowPageScroll: "auto",
            fallbackToMouseEvents: !0,
            excludedElements: ".noSwipe",
            preventDefaultEvents: !0
        };
    $.fn.swipe = function(method) {
        var $this = $(this),
            plugin = $this.data(PLUGIN_NS);
        if (plugin && "string" == typeof method) {
            if (plugin[method]) return plugin[method].apply(plugin, Array.prototype.slice.call(arguments, 1));
            $.error("Method " + method + " does not exist on jQuery.swipe")
        } else if (plugin && "object" == typeof method) plugin.option.apply(plugin, arguments);
        else if (!(plugin || "object" != typeof method && method)) return init.apply(this, arguments);
        return $this
    }, $.fn.swipe.version = VERSION, $.fn.swipe.defaults = defaults, $.fn.swipe.phases = {
        PHASE_START: PHASE_START,
        PHASE_MOVE: PHASE_MOVE,
        PHASE_END: PHASE_END,
        PHASE_CANCEL: PHASE_CANCEL
    }, $.fn.swipe.directions = {
        LEFT: LEFT,
        RIGHT: RIGHT,
        UP: UP,
        DOWN: DOWN,
        IN: IN,
        OUT: OUT
    }, $.fn.swipe.pageScroll = {
        NONE: NONE,
        HORIZONTAL: HORIZONTAL,
        VERTICAL: VERTICAL,
        AUTO: AUTO
    }, $.fn.swipe.fingers = {
        ONE: 1,
        TWO: 2,
        THREE: 3,
        FOUR: 4,
        FIVE: 5,
        ALL: ALL_FINGERS
    }
});;
(function(g) {
    var f = {
        images: [],
        sequence: "",
        from: 0,
        to: 1,
        step: 1,
        folder: "pic/",
        grid: {
            height: 800,
            width: 600,
            rows: 1,
            columns: 1
        },
        loader: {
            path: "img/loader4x4.png",
            height: 40,
            width: 40,
            rows: 4,
            columns: 4
        },
        fps: 12,
        width: 640,
        height: 480,
        loadParallel: 1,
        repeat: true,
        playOnLoad: false,
        performStop: true,
        playBackwards: false,
        showPreLoader: false,
        verbose: true,
        clipQueue: []
    };
    var e = {
        init: function(k) {
            var l = g.extend(true, {}, f);
            if (k != undefined) {
                g.extend(l, k)
            }
            return this.each(function() {
                var q = g(this).data("jsMovie");
                if (!q) {
                    g(this).data("settings", l);
                    g(this).data("jsMovie", g(this));
                    if (g(this).data("settings").sequence !== "") {
                        g(this).data("settings").images = [];
                        var s;
                        for (var p = parseInt(g(this).data("settings").from); p <= parseInt(g(this).data("settings").to); p = p + parseInt(g(this).data("settings").step)) {
                            var m = 1;
                            if (p > 0) {
                                m = (Math.floor(Math.log(p) / Math.log(10)) + 1)
                            }
                            s = new RegExp("^(.*?)([#]{1," + m + "}?)([^#]+)", "g");
                            var t = s.exec(g(this).data("settings").sequence);
                            g(this).data("settings").images.push((t[1] + p + t[3]).replace(/#/g, "0"))
                        }
                    }
                    g(this).data("restoreCss", {
                        width: g(this).width(),
                        height: g(this).height(),
                        overflow: g(this).css("overflow")
                    });
                    g(this).css({
                        width: g(this).data("settings").width,
                        height: g(this).data("settings").height,
                        overflow: "hidden"
                    });
                    g(this).data("currentFrame", g(this));
                    var o = 0;
                    for (var r = 0; r < g(this).data("settings").images.length; r++) {
                        for (var v = 0; v < g(this).data("settings").grid.rows; v++) {
                            for (var n = 0; n < g(this).data("settings").grid.columns; n++) {
                                g(this).data("frame" + o, g("<div class='jsMovieFrame' />"));
                                g(this).append(g(this).data("frame" + o));
                                g(this).data("currentFrame", g(this).data("frame" + o));
                                g(this).data("currentFrame").hide();
                                g(this).data("frame" + o).css({
                                    width: g(this).data("settings").width,
                                    height: g(this).data("settings").height,
                                    "background-position": (-g(this).data("settings").grid.width * n) + "px " + (-g(this).data("settings").grid.height * v) + "px",
                                    "background-repeat": "no-repeat"
                                }).data("frame", o + 1);
                                o++
                            }
                        }
                    }
                    g(this).data("currentStatus", "stopped");
                    g(this).bind("play", d);
                    g(this).bind("stop", c);
                    g(this).bind("pause", b);
                    g(this).data("frame0") && g(this).data("frame0").show();
                    g(this).data("currentFrame", g(this).data("frame0"));
                    g(this).data("currentFrame").css({
                        "background-image": 'url("' + g(this).data("settings").folder + g(this).data("settings").images[0] + '")'
                    });
                    g(this).append("<div id='jsMovie_event_overlay'></div>");
                    g(this).append("<div id='jsMovie_image_preload_container'></div>");
                    var u = g(this);
                    g("#jsMovie_event_overlay").css({
                        width: g(u).data("settings").width,
                        height: g(u).data("settings").height * 2,
                        "margin-top": "-" + (g(u).data("settings").height * 2) + "px"
                    });
                    a.apply(g(this));
                    i.apply(g(this))
                } else {
                    e.throwError(1)
                }
            })
        },
        option: function(k, l) {
            if (l == undefined) {
                return this.data("settings")[k]
            } else {
                this.data("settings")[k] = l;
                return this
            }
        },
        realFps: function() {
            return g(this).data("realFps")
        },
        play: function(k, m, n, o) {
            if (this.data("loadStatus") != "loaded") {
                var l = this;
                this.bind("loaded.playDeferrer", function() {
                    e.play.apply(l, [k, m, n, o])
                });
                return this
            }
            if (k === undefined || k === null) {
                k = 1
            }
            if (m === undefined || m === null) {
                m = g(this).data("settings").images.length * g(this).data("settings").grid.rows * g(this).data("settings").grid.columns
            }
            if (n === undefined || n === null) {
                n = g(this).data("settings").repeat
            }
            if (o === undefined) {
                o = g(this).data("settings").performStop
            }
            g(this).data("currentStatus", "play");
            g(this).trigger("play", [k, m, n, o]);
            return this
        },
        pause: function() {
            g(this).data("currentStatus", "paused");
            g(this).trigger("pause");
            return this
        },
        stop: function() {
            g(this).data("currentStatus", "stopped");
            g(this).trigger("stop");
            return this
        },
        gotoFrame: function(l) {
            var k = this;
            g(this).find(".jsMovieFrame").each(function(m, n) {
                if (l == g(this).data("frame") && g(this).data("loaded") !== undefined) {
                    g(k).find(".jsMovieFrame").hide();
                    g(k).data("currentFrame", g(this));
                    g(k).data("currentFrame").show()
                } else {
                    g(k).data("gotoFrameOnLoaded", l)
                }
            });
            return this
        },
        nextFrame: function() {
            if (g(this).data("currentFrame").next(".jsMovieFrame").length == 0) {
                g(this).data("frame0").show();
                g(this).data("currentFrame").hide();
                g(this).data("currentFrame", g(this).data("frame0"))
            } else {
                g(this).data("currentFrame").next().show();
                g(this).data("currentFrame").hide();
                g(this).data("currentFrame", g(this).data("currentFrame").next())
            }
            return this
        },
        previousFrame: function() {
            if (g(this).data("currentFrame").data("frame") != 1) {
                g(this).data("currentFrame").prev().show();
                g(this).data("currentFrame").hide();
                g(this).data("currentFrame", g(this).data("currentFrame").prev())
            } else {
                g(this).data("currentFrame").siblings(".jsMovieFrame").last().show();
                g(this).data("currentFrame").hide();
                g(this).data("currentFrame", g(this).data("currentFrame").siblings(".jsMovieFrame").last())
            }
            return this
        },
        playClip: function(k, l, m) {
            if (l === undefined) {
                l = g(this).data("settings").repeat
            }
            if (k === undefined) {
                e.play.apply(this)
            }
            if (m === undefined) {
                m = true
            }
            if (typeof k == "object") {
                _clip = k
            }
            if (typeof k == "string") {
                _clip = e.getClip.apply(this, [k])
            }
            if (typeof k == "function") {
                _clip = k()
            }
            if (typeof k == "number") {
                if (k < 0) {
                    k = 0
                }
                if (k > this.data("settings").clipQueue.length) {
                    k = this.data("settings").clipQueue.length - 1
                }
                _clip = this.data("settings").clipQueue[parseInt(k)]
            }
            if (_clip) {
                if (this.data("settings").playBackwards) {
                    e.gotoFrame.apply(this, [_clip.end])
                } else {
                    e.gotoFrame.apply(this, [_clip.start])
                }
                e.play.apply(this, [_clip.start, _clip.end, l, m])
            } else {
                e.throwError(3)
            }
            return this
        },
        playClips: function() {
            var l = this;
            if (this.data("settings").clipQueue.length < 1) {
                e.play.apply(this)
            } else {
                if (this.data("currentClip") === undefined) {
                    this.data("currentClip", l.data("settings").playBackwards ? l.data("settings").clipQueue.length - 1 : 0)
                }
                var k = this.data("settings").clipQueue[this.data("currentClip") <= 0 ? this.data("settings").clipQueue.length - 1 : this.data("currentClip") - 1];
                var m = this.data("settings").clipQueue[this.data("currentClip")];
                e.playClip.apply(this, [this.data("currentClip"), false]);
                this.bind("ended.playClips", function(n) {
                    g(this).unbind(".playClips");
                    if (!(m.pause > 0)) {
                        m.pause = 0
                    }
                    e.gotoFrame.apply(g(this), [l.data("settings").playBackwards ? m.start : m.end]);
                    setTimeout(function() {
                        if (l.data("settings").playBackwards) {
                            if (l.data("settings").repeat) {
                                l.data("currentClip", l.data("currentClip") <= 0 ? l.data("settings").clipQueue.length - 1 : l.data("currentClip") - 1);
                                e.playClips.apply(l)
                            } else {
                                if (l.data("currentClip") > 0) {
                                    l.data("currentClip", l.data("currentClip") - 1);
                                    e.playClips.apply(l)
                                }
                            }
                        } else {
                            if (l.data("settings").repeat) {
                                l.data("currentClip", l.data("currentClip") == l.data("settings").clipQueue.length - 1 ? 0 : l.data("currentClip") + 1);
                                e.playClips.apply(l)
                            } else {
                                if (l.data("currentClip") < l.data("settings").clipQueue.length - 1) {
                                    l.data("currentClip", l.data("currentClip") + 1);
                                    e.playClips.apply(l)
                                }
                            }
                        }
                    }, g(this).data("settings").playBackwards ? k.pause : m.pause)
                })
            }
        },
        addClip: function(l, o, k, n, m) {
            if (n === undefined) {
                n = 0
            }
            if (m === undefined) {
                m = g(this).data("settings").clipQueue.length
            }
            if (o >= 1 && k <= g(this).data("settings").images.length * g(this).data("settings").grid.rows * g(this).data("settings").grid.columns && m <= g(this).data("settings").clipQueue.length) {
                newClip = {
                    name: l,
                    start: o,
                    end: k,
                    pause: n
                };
                g(this).data("settings").clipQueue.splice(m, 0, newClip)
            } else {
                e.throwError(2)
            }
            return this
        },
        getClip: function(k) {
            for (var l in g(this).data("settings").clipQueue) {
                if (g(this).data("settings").clipQueue[l].name == k) {
                    return g(this).data("settings").clipQueue[l]
                }
            }
            return undefined
        },
        removeClip: function(l) {
            for (var k in g(this).data("settings").clipQueue) {
                if (g(this).data("settings").clipQueue[k].name == l || g(this).data("settings").clipQueue[k] === l) {}
            }
            return this
        },
        getClipQueue: function() {
            return g(this).data("settings").clipQueue
        },
        destroy: function() {
            return this.each(function() {
                g(this).children().remove();
                g(this).css(g(this).data("restoreCss"));
                clearInterval(g(this).data("playingInterval"));
                g(this).removeData()
            })
        },
        throwError: function(l) {
            var k = "";
            if (l != undefined) {
                if (l == 1) {
                    k = "This Objekt has already been initialized!"
                } else {
                    if (l == 2) {
                        k = "Clip out of Range!"
                    } else {
                        if (l == 3) {
                            k = "Clip not Found!"
                        } else {
                            if (true) {
                                k = "Unknown Error"
                            }
                        }
                    }
                }
            } else {
                k = "Unknown Error"
            }
            if (window.console) {
                console.log(k)
            } else {
                alert(k)
            }
            return this
        }
    };

    function d(p, k, m, n, o) {
        if (k === undefined || k < 1) {
            k = 1
        }
        if (m === undefined || m > g(this).data("settings").images.length * g(this).data("settings").grid.rows * g(this).data("settings").grid.columns) {
            m = g(this).data("settings").images.length * g(this).data("settings").grid.rows * g(this).data("settings").grid.columns
        }
        if (n === undefined) {
            n = g(this).data("settings").repeat
        }
        if (o === undefined) {
            o = true
        }
        if (g(this).data("currentStatus") == "play") {
            clearInterval(g(this).data("playingInterval"));
            g(this).data("currentStatus", "playing");
            var l = this;
            g(this).data("playingInterval", setInterval(function() {
                if (g(l).data("realFpsTimeStamp") != undefined) {
                    g(l).data("realFps", 1 / (((new Date()).getTime() - g(l).data("realFpsTimeStamp")) / 1000))
                } else {
                    g(l).data("realFps", g(l).data("settings").fps)
                }
                g(l).data("realFpsTimeStamp", (new Date()).getTime());
                if (g(l).data("settings").playBackwards) {
                    if (g(l).data("currentFrame").data("frame") == k && !n) {
                        if (o) {
                            g(l).trigger("stop")
                        } else {
                            g(l).trigger("pause")
                        }
                        g(l).trigger("ended")
                    } else {
                        g(l).trigger("playing");
                        if (g(l).data("currentFrame").data("frame") != k) {
                            e.previousFrame.apply(g(l))
                        } else {
                            e.gotoFrame.apply(g(l), [m])
                        }
                    }
                } else {
                    if (g(l).data("currentFrame").data("frame") == m && !n) {
                        if (o) {
                            g(l).trigger("stop")
                        } else {
                            g(l).trigger("pause")
                        }
                        g(l).trigger("ended")
                    } else {
                        g(l).trigger("playing");
                        if (g(l).data("currentFrame").data("frame") != m) {
                            e.nextFrame.apply(g(l))
                        } else {
                            e.gotoFrame.apply(g(l), [k])
                        }
                    }
                }
            }, 1000 / g(this).data("settings").fps))
        }
    }

    function c(k) {
        clearInterval(g(this).data("playingInterval"));
        g(this).find(".jsMovieFrame").hide();
        g(this).data("currentFrame", g(this).data("frame0"));
        g(this).data("currentFrame").show();
        g(this).data("currentStatus", "stop")
    }

    function b(k) {
        clearInterval(g(this).data("playingInterval"))
    }

    function a(m) {
        if (m == undefined) {
            m = 0;
            this.data("loadStatus", "loading");
            for (loadParralelCount = 1; loadParralelCount <= this.data("settings").loadParallel; loadParralelCount++) {
                a.apply(g(this), [loadParralelCount])
            }
            return
        }
        if (m > this.data("settings").images.length) {
            this.data("loadStatus", "loaded");
            this.trigger("loaded");
            if (this.data("settings").playOnLoad) {
                e.play.apply(g(this))
            }
            return
        }
        var l = new Image();
        var k = this;
        l.onload = function() {
            var p = g(k).data("settings").grid.rows * g(k).data("settings").grid.columns;
            for (var o = 0; o < p; o++) {
                g(k).data("frame" + (o + ((m - 1) * p))).css({
                    "background-image": "url(" + g(k).data("settings").folder + g(k).data("settings").images[m - 1] + ")"
                });
                g(k).data("frame" + (o + ((m - 1) * p))).data("loaded", true)
            }
            if (g(k).data("gotoFrameOnLoaded") != undefined && Math.ceil(g(k).data("gotoFrameOnLoaded") / p) == m) {
                var n = g(k).data("gotoFrameOnLoaded");
                g(k).removeData("gotoFrameOnLoaded");
                e.gotoFrame.apply(g(k), [n])
            }
            a.apply(g(k), [m + k.data("settings").loadParallel]);
            j.apply(k, ["Image #" + (m) + " has been loaded"]);
            h.apply(g(k))
        };
        l.src = g(this).data("settings").folder + g(this).data("settings").images[m - 1];
        g("#jsMovie_image_preload_container").append(l);
        g(l).css({
            height: "1px",
            width: "1px"
        })
    }

    function i() {
        if (this.data("loadStatus") != "loaded" && g(this).data("settings").showPreLoader) {
            this.append("<div class='loaderOverlay' />").children(".loaderOverlay").css({
                "background-color": "black",
                opacity: 0.8,
                height: this.outerHeight(false) + "px",
                width: this.outerWidth(false) + "px",
                position: "absolute",
                top: this.offset().top + "px",
                left: this.offset().left + "px"
            });
            this.append("<div class='loaderAnimation' />").children(".loaderAnimation").css({
                "background-image": "url(" + g(this).data("settings").loader.path + ")",
                height: g(this).data("settings").loader.height + "px",
                width: g(this).data("settings").loader.width + "px",
                position: "absolute",
                top: (this.offset().top + (this.height() / 2) - (g(this).data("settings").loader.height / 2)) + "px",
                left: (this.offset().left + (this.width() / 2) - (g(this).data("settings").loader.width / 2)) + "px",
                "background-repeat": "no-repeat"
            });
            this.children(".loaderAnimation").data("currentFrame", 0);
            var k = this;
            var l = setInterval(function() {
                if (k.data("loadStatus") == "loaded") {
                    k.children(".loaderOverlay, .loaderAnimation").remove();
                    clearInterval(l)
                }
                var m = k.children(".loaderAnimation").data("currentFrame");
                k.children(".loaderAnimation").css({
                    "background-position": (-g(k).data("settings").loader.width * (m % g(k).data("settings").loader.columns)) + "px " + (-g(k).data("settings").loader.height * Math.floor(m / g(k).data("settings").loader.columns)) + "px"
                });
                k.children(".loaderAnimation").data("currentFrame", (m + 1) % (g(k).data("settings").loader.rows * g(k).data("settings").loader.columns));
                h.apply(g(k))
            }, 100)
        }
    }

    function h() {
        this.children(".loaderOverlay").css({
            top: this.offset().top + "px",
            left: this.offset().left + "px"
        });
        this.children(".loaderAnimation").css({
            top: (this.offset().top + (this.height() / 2) - (g(this).data("settings").loader.height / 2)) + "px",
            left: (this.offset().left + (this.width() / 2) - (g(this).data("settings").loader.width / 2)) + "px"
        })
    }

    function j(k) {
        this.trigger("verbose", k)
    }
    g.fn.jsMovie = function(k) {
        if (e[k]) {
            return e[k].apply(this, Array.prototype.slice.call(arguments, 1))
        } else {
            if (typeof k === "object" || !k) {
                return e.init.apply(this, arguments)
            } else {
                g.error("Method " + k + " does not exist on jQuery.jsMovie")
            }
        }
    }
})(jQuery);;

var AnimVerre = {
    init: function() {

        $(document).ready(function() {
            var totalFrames = 279;
            var previousFrame;
            var currentFrame = 0;

            var animVerre__lang = $('html').attr('lang');
            if (animVerre__lang === "fr-FR") {
                animVerre__lang = "FR";
            } else {
                animVerre__lang = "EN";
            }

            $(".touch .dragTab").swipe({
                swipeStatus: function(event, phase, direction, distance, duration, fingers, fingerData, currentDirection) {
                    var pos1, pos2, pos3, posDragarea, widthDragarea, posFinger;

                    pos1 = parseInt(fingerData[0].start.x);
                    posDragarea = parseInt($("#dragArea")[0].offsetLeft);
                    widthDragarea = parseInt($("#dragArea").width());

                    posFinger = pos1 - posDragarea;
                    if (posFinger >= widthDragarea) {
                        posFinger = widthDragarea;
                    } else if (posFinger < 0) {
                        posFinger = 0;
                    }


                    pos2 = posFinger;
                    if (direction === "left") pos2 = posFinger - distance;
                    else if (direction === "right") pos2 = posFinger + distance;


                    if (pos2 >= widthDragarea) {
                        pos2 = widthDragarea;
                    } else if (pos2 < 0) {
                        pos2 = 0;
                    }

                    setTimeFromPosition(pos2, 0);

                    /*pos3 = pos2-106; //centrer la scrollbar sur le doigt ( 212/2 = 106)
					if(pos3<106) pos3 = 0;
					if(pos3>widthDragarea-106) pos3 = widthDragarea-106;
		        	$("#slider").css("left",pos3);*/
                },
                threshold: 200,
                maxTimeThreshold: 5000,
                fingers: 'all'
            });


            // ajout des images
            $("#how_lenses_work").empty();

            for (var i = 0; i <= totalFrames; i++) {
                var frame = i;
                if (frame < 10) {
                    frame = "00" + i;
                } else if (frame < 100) {
                    frame = "0" + i;
                }

                var height = $('.animVerre__content').width() / 16 * 9;

                $("#how_lenses_work").append('<div class="picture" id="' + frame + '""><img src="' + animeVerre.theme_directory + '/img/anim-verre/' + animVerre__lang + '/essilor' + frame + '.jpg" width="100%" height="' + height + '" /></div>');

                $(".animVerre__content, .dragTab").height(height);
            }

            // Change loader infinite
            var $target = $('#loaderIcon');
            var counter = 0;

            this.loaderInfinite = setInterval(function() {
                counter++;
                $target.attr('class', '');
                $target.addClass('sprite-loader-2_000' + counter);
                if (counter > 63) {

                    $target.addClass('sprite-loader-2_00014');
                    counter = 14;
                }
            }, 40);

            $(window).load(function() {

                $(".launchAnim__js").click(function(e) {
                    e.preventDefault();
                    anim1();
                    $('.cardBox14').hide();
                });

                $("#loader").css("display", "none");

                // lancement de la vidÃ©o :

                function anim1() {
                    var a = setInterval(function() {
                        //console.log(currentFrame);
                        if (previousFrame) {
                            $("#" + previousFrame).css("visibility", "hidden");
                        }

                        if (currentFrame < 10) {
                            currentFrame = "00" + currentFrame;
                        } else if (currentFrame < 100) {
                            currentFrame = "0" + currentFrame;
                        }
                        $("#" + currentFrame).css("visibility", "visible");

                        previousFrame = currentFrame;
                        currentFrame++;

                        if (currentFrame > totalFrames) {
                            clearInterval(a);

                            // apparition du slider
                            var rewind = $("#dragArea").width() / 6;

                            $("#dragArea").show("fast", function() {
                                $("#slider").css("left", $("#dragArea").width() - $("#slider").width());
                                $("#slider").animate({
                                    'left': '-=' + rewind * 2 + "px"
                                }, 2000, function() {
                                    $("#slider").animate({
                                        'left': '+=' + rewind + "px"
                                    }, 2000, function() {
                                        // remove interval
                                        clearInterval(a);

                                        $("#slider").draggable({
                                            axis: 'x',
                                            containment: $("#dragArea"),
                                            drag: handleDragMove
                                        });
                                    });
                                });

                                // demo utilisation
                                var o = $("#slider"); // our jquery object
                                var lastPos = null;
                                var newPos = o.position();

                                var a = setInterval(function() {
                                    var offsetXPos = parseInt($("#slider").css("left"));
                                    setTimeFromPosition(offsetXPos, 1);
                                }, 50);
                            });
                        }
                    }, 66);

                }

            });



            function handleDragMove(event, ui) {
                var offsetXPos = parseInt($("#slider").css("left"));
                setTimeFromPosition(offsetXPos, 1);
            }

            function setTimeFromPosition(position, fromDrag) {
                //console.log("position"+position);
                // on enleve le debut de la vidÃ©o (introduction)

                this.fromDrag = fromDrag;

                if (previousFrame) {
                    $("#" + previousFrame).css("visibility", "hidden");
                }

                var introToRemove = 0;

                if (this.fromDrag === 1) {
                    var ratio = position / ($("#dragArea").width() - $("#slider").width());
                } else {
                    var ratio = position / $("#dragArea").width();
                }

                var nextFrame = Math.floor((totalFrames - introToRemove) * ratio) + introToRemove;
                if (nextFrame < 10) {
                    nextFrame = "00" + nextFrame;
                } else if (nextFrame < 100) {
                    nextFrame = "0" + nextFrame;
                }
                $("#" + nextFrame).css("visibility", "visible");
                previousFrame = nextFrame;
            }

            $(window).resize(function() {
                // replace le slider
                var left = previousFrame / totalFrames * ($("#dragArea").width() - $("#slider").width());
                $("#slider").css("left", parseInt(left));

                var height = $('.animVerre__content').width() / 16 * 9;
                $(".picture").find("img").height(height);
                $(".animVerre__content").height(height);
            });

        });

    }
}

AnimVerre.init();

//# sourceMappingURL=mainProd.js.map